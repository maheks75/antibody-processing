#SCRIPT1.PY
import sys
from Bio import SeqIO

# Get input and output file paths from command-line arguments
input_fastq_file = sys.argv[1]
output_file_with_g = sys.argv[2]
output_file_without_g = sys.argv[3]

with open(output_file_with_g, 'w') as output_handle_with_g, open(output_file_without_g, 'w') as output_handle_without_g:
    for i, record in enumerate(SeqIO.parse(input_fastq_file, "fastq")):
        sequence_data = str(record.seq)[:25]

        if "GGGGG" in sequence_data:
            output_handle_with_g.write(f"{sequence_data}\n")
        else:
            output_handle_without_g.write(f"{sequence_data}\n")
#SCRIPT2.PY
import sys
from Bio import SeqIO

input_txt_file = sys.argv[1]
target_sequence = 'GGGGG'
output_file = sys.argv[2]
sequences_written = 0

with open(input_txt_file, "r") as file, open(output_file, 'w') as output_handle:
    strings = [line.strip() for line in file]
    for string in strings:
        if target_sequence in string[:18]:
            extracted_sequence = string[:12]
            output_handle.write(extracted_sequence + "\n")
            sequences_written += 1
            print("Extracted Sequence:", extracted_sequence)
        else:
            print("Pattern 'GGGGG' not found or is too close to the start of the sequence.")

print(f"Number of sequences written to {output_file}: {sequences_written}")
#SCRIPT3.PY
import sys
filename = sys.argv[1]

# Read the strings from the file
with open(filename, 'r') as file:
    strings = [line.strip() for line in file]

string_count = {}
for string in strings:
    if string in string_count:
        string_count[string] += 1
    else:
        string_count[string] = 1

repeating_strings_count = 0
non_repeating_strings_count = 0

repeating_filename = sys.argv[2]
non_repeating_filename = sys.argv[3]

repeating_strings = []
non_repeating_strings = []

# Separate repeating and non-repeating strings
for string, count in string_count.items():
    if count > 1:
        repeating_strings.append((string, count))
        repeating_strings_count += count
    else:
        non_repeating_strings.append((string, count))
        non_repeating_strings_count += count

repeating_strings.sort(key=lambda x: x[1], reverse=True)
non_repeating_strings.sort(key=lambda x: x[1], reverse=True)

# Write repeating strings to file with count
with open(repeating_filename, 'w') as file:
    for string, count in repeating_strings:
        file.write(f"{string}: {count}\n")

# Write non-repeating strings to file with count
with open(non_repeating_filename, 'w') as file:
    for string, count in non_repeating_strings:
        file.write(f"{string}: {count}\n")

# Calculate the total number of strings
total_strings_count = len(strings)

print("Total number of strings:", total_strings_count)
print("Sum of counts for repeating strings:", repeating_strings_count)
print("Sum of counts for non-repeating strings:", non_repeating_strings_count)
#SCRIPT4.PY
import sys
filename = sys.argv[1]

# Read the strings from the file
with open(filename, 'r') as file:
    count = 0
    twostringlist = []
    multiplestring = []
    strings = [line.strip() for line in file]
    for string in strings:
        parts = string.split(':')
        if int(parts[1]) == 2:
            twostringlist.append(parts[0])
            
        else:
            multiplestring.append(parts[0])
            

with open(sys.argv[2], 'w') as file:
                for i, stringg in enumerate(twostringlist):
                    print(stringg)
                    file.write(f"{stringg} \n")
        
with open(sys.argv[3], 'w') as file:
                for i, stringgg in enumerate(multiplestring):
                    print(stringgg)
                    file.write(f"{stringgg} \n") 
#SCRIPT8.PY
import sys
from Bio import SeqIO
from multiprocessing import Pool, Manager

# Function to process a single string
def process_string(string, seq_number):
    sequences = []
    
    # Open the output file within the process_string function
    with open(sys.argv[4], "a") as outfile:
        for record in SeqIO.parse(input_fastq_file, "fastq"):
            sequence = str(record.seq)
            if string in sequence[:12]:
                sequences.append(sequence)        
        if sequences:
            consensus_sequence = calculate_consensus(sequences)
            percentage_low_mismatch = calculate_percentage_low_mismatch(sequences, consensus_sequence)
            
            sequence_header = f">Seq{seq_number.value}"  # Access the shared seq_number using .value
            outfile.write(f">Seq{seq_number.value} : {len(sequences)} : {percentage_low_mismatch}\n{consensus_sequence}\n")
            seq_number.value += 1

def calculate_consensus(sequences):
    length_counts = {}
    consensus_sequence = ""
    #print(sequences)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length in length_counts:
            length_counts[seq_length] += 1
        else:
            length_counts[seq_length] = 1
    most_common_length = max(length_counts, key=length_counts.get)
    #print(most_common_length)
    for seq in sequences:
        if len(seq) == most_common_length:
            consensus_sequence = ""
            BASES_CALCULATE = {"A": 0, "C": 0, "G": 0, "T": 0, "N": 0}
            bases = ["A", "C", "G", "T", "N"]
            for i in range(len(seq)):
                for base in bases:
                    BASES_CALCULATE[base] = 0
                for j in range(len(sequences)):
                    if len(sequences[j]) > i:
                        base = sequences[j][i]
                        BASES_CALCULATE[base] += 1
                most_common_base = max(BASES_CALCULATE, key=BASES_CALCULATE.get)
                consensus_sequence += most_common_base 
    #print(consensus_sequence)
    return consensus_sequence

def calculate_percentage_low_mismatch(sequences, consensus_sequence):
    length_counts = {}
    seq_list = []
    mismatch_threshold = 2
    total_sequences = 0
    low_mismatch_count = 0  
    #print(sequences)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length in length_counts:
            length_counts[seq_length] += 1
        else:
            length_counts[seq_length] = 1
    most_common_length = max(length_counts, key=length_counts.get)
    #print(most_common_length)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length == most_common_length:
            seq_list.append(seq)
    #print(consensus_sequence)   
    for se in seq_list:
        mismatch_count = 0
        for i in range(len(se)):
            if se[i] != consensus_sequence[i]:
                mismatch_count += 1
        #print(mismatch_count)
        if mismatch_count <= mismatch_threshold:
            low_mismatch_count += 1
    #print(low_mismatch_count)
    percentage_low_mismatch = (low_mismatch_count / len(seq_list)) * 100 if len(seq_list) > 0 else 0
    #print(percentage_low_mismatch)
    return percentage_low_mismatch

if __name__ == "__main__":
    input_fastq_file = sys.argv[1]
    
    with open(sys.argv[2], 'r') as file:
        strings = [line.strip() for line in file]
    
    # Number of CPU cores to use for multiprocessing
    num_cores = 32  # You can adjust this based on your machine's capabilities
    
    with Manager() as manager:
        seq_number = manager.Value('i', 1)  # Create a shared integer variable
        
        with Pool(processes=num_cores) as pool:
            pool.starmap(process_string, [(string, seq_number) for string in strings])
            
            
def process_string(string, seq_number):
    sequences = []
    
    # Open the output file within the process_string function
    with open(sys.argv[5], "a") as outfile:
        for record in SeqIO.parse(input_fastq_file, "fastq"):
            sequence = str(record.seq)
            if string in sequence[:12]:
                sequences.append(sequence)        
        if sequences:
            consensus_sequence = calculate_consensus(sequences)
            percentage_low_mismatch = calculate_percentage_low_mismatch(sequences, consensus_sequence)
            
            sequence_header = f">Seq{seq_number.value}"  # Access the shared seq_number using .value
            outfile.write(f">Seq{seq_number.value} : {len(sequences)} : {percentage_low_mismatch}\n{consensus_sequence}\n")
            seq_number.value += 1

def calculate_consensus(sequences):
    length_counts = {}
    consensus_sequence = ""
    #print(sequences)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length in length_counts:
            length_counts[seq_length] += 1
        else:
            length_counts[seq_length] = 1
    most_common_length = max(length_counts, key=length_counts.get)
    #print(most_common_length)
    for seq in sequences:
        if len(seq) == most_common_length:
            consensus_sequence = ""
            BASES_CALCULATE = {"A": 0, "C": 0, "G": 0, "T": 0, "N": 0}
            bases = ["A", "C", "G", "T", "N"]
            for i in range(len(seq)):
                for base in bases:
                    BASES_CALCULATE[base] = 0
                for j in range(len(sequences)):
                    if len(sequences[j]) > i:
                        base = sequences[j][i]
                        BASES_CALCULATE[base] += 1
                most_common_base = max(BASES_CALCULATE, key=BASES_CALCULATE.get)
                consensus_sequence += most_common_base 
    #print(consensus_sequence)
    return consensus_sequence

def calculate_percentage_low_mismatch(sequences, consensus_sequence):
    length_counts = {}
    seq_list = []
    mismatch_threshold = 2
    total_sequences = 0
    low_mismatch_count = 0  
    #print(sequences)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length in length_counts:
            length_counts[seq_length] += 1
        else:
            length_counts[seq_length] = 1
    most_common_length = max(length_counts, key=length_counts.get)
    #print(most_common_length)
    for seq in sequences:
        seq_length = len(seq)
        if seq_length == most_common_length:
            seq_list.append(seq)
    #print(consensus_sequence)   
    for se in seq_list:
        mismatch_count = 0
        for i in range(len(se)):
            if se[i] != consensus_sequence[i]:
                mismatch_count += 1
        #print(mismatch_count)
        if mismatch_count <= mismatch_threshold:
            low_mismatch_count += 1
    #print(low_mismatch_count)
    percentage_low_mismatch = (low_mismatch_count / len(seq_list)) * 100 if len(seq_list) > 0 else 0
    #print(percentage_low_mismatch)
    return percentage_low_mismatch

if __name__ == "__main__":
    input_fastq_file = sys.argv[1]
    
    with open(sys.argv[3], 'r') as file:
        strings = [line.strip() for line in file]
    
    # Number of CPU cores to use for multiprocessing
    num_cores = 32  # You can adjust this based on your machine's capabilities
    
    with Manager() as manager:
        seq_number = manager.Value('i', 1)  # Create a shared integer variable
        
        with Pool(processes=num_cores) as pool:
            pool.starmap(process_string, [(string, seq_number) for string in strings])
#SCRIPT6.PY
import sys
from Bio import SeqIO
import subprocess
input_file1 = sys.argv[1]       
input_file2 = sys.argv[2] 
output_file_step7 = sys.argv[3]
all_sequences_step7 = []
for record in SeqIO.parse(input_file1, "fasta"): 
    sequences1 = str(record.seq)
    all_sequences_step7.append(sequences1)
for record in SeqIO.parse(input_file2, "fasta"): 
    sequences2 = str(record.seq)
    all_sequences_step7.append(sequences2)
with open(output_file_step7, "w") as output_handle:
      for i, all_seqs in enumerate(all_sequences_step7):
        sequence_header = f">Seq{i + 1}"
        output_handle.write(sequence_header + "\n" + all_seqs + "\n")
#SCRIPT7.PY
import sys
from Bio import SeqIO
import subprocess
input_fasta = sys.argv[1]
output_fasta = sys.argv[2]
igblast_cmd = [
     'igblastn',
     '-query', input_fasta,
     '-out', output_fasta,
     '-germline_db_V', 'Alpaca_V',
     '-germline_db_J', 'Alpaca_J',
     '-germline_db_D', 'Alpaca_D',
     '-auxiliary_data','camelid_gl.aux',
     '-num_threads', '32',
     '-outfmt', '19',  
]
try:
    subprocess.run(igblast_cmd, check=True)
    print("IgBLAST analysis complete. Output saved to:", output_fasta)
except subprocess.CalledProcessError as e:  
    print("Error running IgBLAST:", e)
